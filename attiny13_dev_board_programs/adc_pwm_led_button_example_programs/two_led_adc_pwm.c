/*
 * tiny13_board_adc_pwm
 * Демо-прошивка отладочной платы на ATtiny13.
 * Демонстрация работы ШИМ-регулятора (в режиме коррекции фазы) на двух каналах:
 * неинверсный сигнал на выходе OC0A, инверсный - на выходе OC0B.
 * ШИМ-сигнал регулируется переменным резистором:
 * напряжение с него подаётся на вход АЦП
 * и, в зависимости от величины измеренного напряжения,
 * изменяется время отсчёта для таймера ШИМ.
 */
 
#define F_CPU 1200000UL
#include <avr/io.h>
#include <avr/interrupt.h>

#define LED0 PB0 // OC0A
#define LED1 PB1 // OC0B
#define ANALOG_IN PB3 // ADC3

// Обработчик прерывания по завершению преобразования АЦП
ISR(ADC_vect)
{
  // Записываем значение, полученное на выходе АЦП в регистры сравнения таймера. 
  // Здесь же, задаём минимальный порог свечения светодиода, после которого он будет гарантированно гаснуть
	OCR0A=(ADCH < 10) ? 0 : ADCH;
	OCR0B=(ADCH > 245) ? 255: ADCH;
}

int main(void)
{
	// Светидиоды:
	DDRB |= (1 << LED0)|(1 << LED1); // выходы = 1
	PORTB &= ~((1 << LED0)|(1 << LED1)); // по умолчанию включены
	// Перем. резистор:
	DDRB &= ~(1 << ANALOG_IN); // вход = 0
	// Таймер для ШИМ:
	TCCR0A = 0xB1; // режим коррекции фазы ШИМ, неинверсный сигнал на выходе OC0A, инверсный - на выходе OC0B
	TCCR0B = 0x02; // предделитель тактовой частоты CLK/8
	TCNT0 = 0; // начальное значение счётчика
	OCR0A = 0; // регистр сравнения A
	OCR0B = 0; // регистр сравнения B
	// Настройка АЦП:
	ADMUX = 0x23; // опорное напряжение - VCC, левое ориентирование данных, выбран вход ADC3 (на нём висит перем. резистор)
	ADCSRA = 0xEA; // АЦП включен, запуск преобразования, режим автоизмерения, прерывание по окончанию преобразования, частота CLK/4
	ADCSRB = 0x00; // режим автоизмерения: постоянно запущено
	DIDR0 |= (1 << ANALOG_IN); // запрещаем цифровой вход на ноге аналогового входа
  
	sei(); //разрешаем глобально прерывания
  
	while(1)
	{
	}
}
