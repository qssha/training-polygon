/*
 * attiny13 led pwm using adc and button interrupt with pwm state swap

 * Демонстрация работы ШИМ-регулятора (в режиме коррекции фазы) на двух каналах:
 * неинверсный сигнал на выходе OC0A, инверсный - на выходе OC0B.
 * ШИМ-сигнал регулируется переменным резистором:
 * напряжение с него подаётся на вход АЦП
 * и, в зависимости от величины измеренного напряжения,
 * изменяется время отсчёта для таймера ШИМ.
 * При нажатии на кнопку BUTTON0 срабатывает прерывание и меняется состояние
 * светодиодов в зависимости от показателя на входе АЦП.
 * При нажатии на кнопку BUTTON1 срабатывает прерывание и инвертируется режим ШИМ
 * светодиодов.
 */

#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>

#define F_CPU 1200000UL

#define LED0 PB0 // OC0A
#define LED1 PB1 // OC0B

#define ANALOG_IN PB3 // ADC3

#define BUTTON0 PB2
#define BUTTON1 PB4

// обработчик прерываний PCINT0
ISR(PCINT0_vect)
{
	_delay_ms (50); // антидребезг кнопки
	if ((PINB & (1 << BUTTON0)) == 0) 
	{
		OCR0A=(ADCH < 10) ? 0 : ADCH;
		OCR0B=(ADCH > 245) ? 255: ADCH;
	} else if ((PINB & (1 << BUTTON1)) == 0)
	{
		TCCR0A ^= (1 << COM0A0) | (1 << COM0B0); // инвертируем режим работы ШИМ на выходах OC0A и OC0B
	}
	while (((PINB & (1 << BUTTON0)) == 0) | ((PINB & (1 << BUTTON1)) == 0)) {} 
}

int main(void)
{
	// Светидиоды:
	DDRB |= (1 << LED0)|(1 << LED1); // выходы = 1
	PORTB &= ~((1 << LED0)|(1 << LED1)); // по умолчанию включены

	// Перем. резистор:
	DDRB &= ~(1 << ANALOG_IN); // вход = 0

	// Таймер для ШИМ:
	TCCR0A = 0xB1; // режим коррекции фазы ШИМ, неинверсный сигнал на выходе OC0A, инверсный - на выходе OC0B
	TCCR0B = 0x02; // предделитель тактовой частоты CLK/8
	TCNT0 = 0; // начальное значение счётчика
	OCR0A = 0; // регистр сравнения A
	OCR0B = 0; // регистр сравнения B

	// Настройка прерывания по кнопке BUTTON
	
	DDRB &= ~((1 << BUTTON0) | (1 << BUTTON1)); // выставляем пин BUTTON на вход
	PORTB |= (1 << BUTTON0) | (1 << BUTTON1);  // включаем подтягивание внутреннего резистора

	GIMSK |= (1 << PCIE); // включить внешние прерывания enable external interrupt
	PCMSK |= (1 << BUTTON0) | (1 << BUTTON1); // включить прерывание по пину BUTTON0

	// Настройка АЦП:
	ADMUX = 0x23; // опорное напряжение - VCC, левое ориентирование данных, выбран вход ADC3 (на нём висит перем. резистор)
	ADCSRA = 0xE2; // АЦП включен, запуск преобразования, режим автоизмерения, запретить прерывание по окончанию преобразования, частота CLK/4
	ADCSRB = 0x06; // режим автоизмерения: внешнее прерывание PCINT0
	DIDR0 |= (1 << ANALOG_IN); // запрещаем цифровой вход на ноге аналогового входа
  
	sei(); //разрешаем глобально прерывания
  
	while(1)
	{
	}
}
